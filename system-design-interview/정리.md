# 📖 가상 면접 사례로 배우는 대규모 시스템 설계 기초

<div align = "center">
   <a href="https://www.yes24.com/Product/Goods/102819435">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/XL" alt="가상 면접 사례로 배우는 대규모 시스템 설계 기초 - 예스24" style="width:200px;" />
  </a>
</div>

<br>

**규모 확장성을 갖춘 시스템을 만들기 위한 지식들이 무엇이 있는지 궁금해서 읽기 시작했습니다.**


<details>

<summary><h2> Chapter 1. 사용자 수에 따른 규모 확장성 </h2></summary>

### 📌 어떤 데이터 베이스를 사용할 것인가? (NoSQL vs RDBMS)
   
   <br>

  관계형 데이터베이스는 자료를 테이블과 열, 칼럼으로 표현한다. SQL을 이용해 테이블에 있는 데이터를 그 관계에 따라 조인하여 합칠 수 있다. 
  
  40년 이상 시장에서 잘 사용되어 온 시스템이고 **정형화된 스키마에 따라 구조화되어 저장되기 때문에, 데이터의 일관성과 무결성을 보장할 수 있다.**
  
  그 외, **DB에서 제공하는 무결성 유지를 위한 기능이나 보안, 확장 기능이 있기 때문에 사용한다.**
  
  <br>
  
  NoSQL은 대량의 데이터를 처리하는데 특화되어 있기 때문에 다루려는 **데이터가 비정형이거나 아주 많은 양의 데이터를 저장할 필요가 있을 때** 사용하면 좋다.
  
  <br>
  
### 📌 웹 서버 · DB 서버의 다중화 필요성과 로드밸런서의 역할
   
   <br>

  서버의 분산이 필요한 이유는 다음과 같다.
  
  1. 한 서버에 트래픽이 몰리면, 사용할 수 있는 **자원은 한정되어 있고 여러개의 요청을 처리하기 위해 자원을 분배하게 되어 병목현상이 생기고 응답속도가 느려질 수 있다.**
  
  2. 시스템에 문제가 생겨 서버가 다운되는 경우, **데이터를 잃거나 사용자가 서비스를 사용하지 못하는 상황이 발생**할 수 있다.
   
   <br>
   
   데이터베이스의 경우, 여러개의 데이터베이스 서버를 구축하고 샤딩을 하는 방법으로 스케일 아웃을 할 수 있다.  
   
   샤딩이란, 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없고 파티션 키를 통해서 어떤 데이터를 어떤 데이터베이스에 넣을지 결정하고 분배하는 것이다.
   
   
  
  <br>

  로드밸런서는 웹 서버에게 트래픽 부하를 분산하는 역할을 한다. 
  
  사용자는 로드밸런서의 공개 IP 주소로 접속한다. 그리고 웹 서버 간 통신은 보안을 위해 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 사설 IP 주소를 사용한다.
  
   <br>

### 📌 캐시를 사용하는 이유

<br>

캐시 계층을 두면 데이터베이스보다 훨씬 빨라서 성능이 개선될 뿐 아니라 데이터베이스의 부하를 줄일 수 있다.

<br>

- DB에 있는 데이터가 갱신은 자주 일어나지 않지만 **참조(조회)는 빈번하게 일어날 때**

- 캐시는 데이터를 휘발성 메모리에 두므로, **영속적으로 보관할 필요가 있는 데이터를 두는 것을 바람직하지 못하다.**

- **캐시 정책을 잘 세워야한다.** 캐시 만료 기한이 너무 짧으면, 데이터베이스를 너무 자주 읽게 된다. 캐시 만료 기간이 너무 길다면, DB의 데이터와 차이가 날 수 있다.

- 저장소의 **원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리**되어야 일관성을 유지할 수 있다.

- 캐시 서버도 1개만 사용하는 경우, 시스템 장애를 대처하지 못할 수 있다.

- 캐시 데이터 방출 정책은 무엇인가

  > - LRU (Least Recently Used) : 마지막으로 사용된 시점이 가장 오래된 데이터를 내보냄
  > - LFU (Leat Frequently Used) : 사용된 빈도가 가장 낮은 데이터를 내보냄
  > - FIFO (First In First Out) : 가장 먼저 캐시에 들어온 데이터를 가장 먼저 내보냄

<br>

### 📌 무상태(Stateless) 아키텍쳐의 필요성

<br>
사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달될 수 있다. 

웹 서버는 상태 정보가 **필요할 경우 공유 저장소로부터** 데이터를 가져온다.

따라서, 상태 정보는 **웹 서버로부터 물리적으로 분리**되어 있다.

<br>

웹 서버가 다중화되어있을때, 상태를 유지하는 경우 사용자는 본인의 세션 정보를 알고 있는 서버에만 요청을 해야한다.

혹은 서버 간 세션을 공유하도록 해야하는데, 서버에 부담을 줄 수 있다.


  
</details>



<details>

<summary><h2> Chapter 2. 개략적인 규모 측정 </h2></summary>

### 📌 QPS(Query Per Second) 를 측정해보자
   
   <br>



```
가정
- 월간 사용자는 3억명이다.
- 50%의 사용자가 트위터를 매일 사용한다.
- 평균적으로 각 사용자는 매일 2건의 트윗을 올린다.
- 미디어를 포함하는 트윗은 10% 정도다.
- 데이터는 5년간 보관된다.
```

QPS(Query Per Second)는 초당 발생하는 쿼리 수를 나타낸다.

먼저 월간 사용자가 3억명이고, 50%가 매일 트위터를 사용하므로

하루에 1.5억명 정도가 트위터를 사용한다.

<br>

그리고 평균 매일 2건의 트윗을 올리므로 매일 약 3억개의 트윗이 올라온다.

이를 초 단위로 바꾸어주면, 3억/(24시간) = 3억/(24*3600)초 = 약 3500 QPS이 나온다.

최대 QPS 는 2를 곱한 7000 QPS이다.

<br>

대략적인 저장소 용량을 구해보면, 미디어를 포함하는 트윗은 10%이고 미디어를 포함한 트윗이 약 1MB 정도라고 가정해보자.

하루에 약 3억개의 트윗이 올라오므로, 미디어를 포함하는 트윗은 3000만개일 것이다.

트윗 하나당 1MB 이면, 3000만을 곱하면 30TB가 될 것이다.

따라서, 하루에 사용되는 저장소의 용량은 30TB일 것이고, 5년간 보관하기 위한 저장소의 크기는 30TB * 5 * 365 = 약 55PB(페타바이트) 가 된다. 

<br>
  

  
</details>
